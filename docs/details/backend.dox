/**
\addtogroup arrayfire_func
@{

\defgroup unified_func_setbackend setBackend

\brief Set the current backend when using Unified backend

This is a noop when using one of CPU, CUDA, or OpenCL backend.

However, when using on of those 3 but trying to set it to a different backend
will return in an exception.

\ingroup unified_func
\ingroup arrayfire_func

=======================================================================

\defgroup unified_func_addbackendlibrary af_add_backend_library

\brief Adds a new backend library from an arbitrary path on the file system

This function simply registers a new backend library located anywhere in the
file system, given the path of that library (can be a `.so`, `.dll`, or
`.dylib` file, depending on the operating system being used).

Once registered, \ref af_set_backend_library() can be called to activate the
backend library in a program. The order in which a library is added determines
the index to be passed in \ref af_set_backend_library() to activate the desired
library. The number of libraries that can be registered and activated is limited
to 7.

This function, together with \ref af_set_backend_library() can be used to load
different versions of the ArrayFire library at runtime.

This is a noop when using any one of the standalone CPU, CUDA, or OpenCL
backends.

The following is an example of how this can be used:
\code
af_add_backend_library("/path/to/custom/1/afcpu.so");
af_add_backend_library("/path/to/custom/2/afcpu.so");

af_set_backend_library(0); // Activates .../1/afcpu.so
af_set_backend_library(1); // Activates .../2/afcpu.so
\endcode

\ingroup unified_func
\ingroup arrayfire_func

=======================================================================

\defgroup unified_func_setbackendlibrary af_set_backend_library

\brief Activates an ArrayFire library located in an arbitrary path for use

This function is used after the ArrayFire library has been registered through
\ref af_add_backend_library(). The index to be passed in must be the order of
when \ref af_add_backend_library() was called for the target library. This is
can be used to load different versions of the ArrayFire library at runtime.

This is a noop when using any one of the standalone CPU, CUDA, or OpenCL backends.

The following is an example of how this can be used:
\code
af_add_backend_library("/path/to/custom/1/afcpu.so");
af_add_backend_library("/path/to/custom/2/afcpu.so");

af_set_backend_library(0); // Activates .../1/afcpu.so
af_set_backend_library(1); // Activates .../2/afcpu.so
\endcode

\ingroup unified_func
\ingroup arrayfire_func

=======================================================================

\defgroup unified_func_checkunifiedbackend af_check_unified_backend

\brief Returns `true` if the unified backend is used to call ArrayFire functions

This function returns `true` if the unified backend is being used to call the
ArrayFire functions. If the binary is linked directly to one of the backend
libraries, this function returns `false`.

\ingroup unified_func
\ingroup arrayfire_func

=======================================================================

\defgroup unified_func_getbackendcount getBackendCount

\brief Get the number of backends whose libraries were successfully loaded.

This will be between 0-3. 0 Being no backends were loaded and 3 being all
backends loaded successfully.

\ingroup unified_func
\ingroup arrayfire_func

=======================================================================

\defgroup unified_func_getavailbackends getAvailableBackends

\brief Returns an integer indicating the backends loaded successfully.

The number returned denotes the backends available according to the table:

Return Value | Backends Available
-------------|-----------------------
0            | None
1            | CPU
2            | CUDA
3            | CPU and CUDA
4            | OpenCL
5            | CPU and OpenCL
6            | CUDA and OpenCL
7            | CPU, CUDA and OpenCL

To convert the integer back into bools for each device, use the following code
\code
int backends = af::getAvailableBackends();

bool cpu    = backends & AF_BACKEND_CPU;
bool cuda   = backends & AF_BACKEND_CUDA;
bool opencl = backends & AF_BACKEND_OPENCL;
\endcode

\ingroup unified_func
\ingroup arrayfire_func

=======================================================================

\defgroup unified_func_getbackendid getBackendId

\brief Get's the backend enum for an array

This will return one of the values from the \ref af_backend enum.
The return value specifies which backend the array was created on.

\ingroup unified_func
\ingroup arrayfire_func

=======================================================================

\defgroup unified_func_getactivebackend getActiveBackend

\brief Get's the backend enum for the active backend

\ingroup unified_func
\ingroup arrayfire_func

=======================================================================

\defgroup unified_func_getdeviceid getDeviceId

\brief Get's the id of the device an array was created on.

\ingroup unified_func
\ingroup arrayfire_func

=======================================================================

@}
*/
