
/*!

\page signal_func_conv_desc Convolution

A convolution is a common operation between a source array, a, and a filter (or kernel) array b.
The answer to the convolution is the same as computing the coefficients in polynomial multiplication,
if a and b are the coefficients.

Another way to think about it is that the filter kernel is centered on each pixel in a,
and the output for that pixel or data point is the sum of the products.

Depending on the dimensions of the input signal and the filter signal, any one of the following
batch mode convolutions take place.

- **No Batch**   - Single filter applied to single input.
- **Filter is Batched**  - Many filters applied on same input
- **Signal is Batched**  - Single filter applied to a set of inputs.
- **Identical Batches** - A set of filters applied onto to a set of inputs in one-to-one correspondence.
- **Non overlapping Batches** - All batched filters are applied to all batched signals. The batch dimension of Signal and Filter **should not** be the same.



\page signal_func_conv2_batch_desc convolve2

For example, if the signal is two dimensional with m & n as sizes along the 0th & 1st dimensions
respectively, then the possible batch operations are as follows.

| Input Signal Dimensions | Filter Dimensions | Output Dimensions | Batch Mode | Explanation |
|:-----------------------:|:-----------------:|:-----------------:|:----------:|:------------|
| [m n 1 1] | [m n 1 1] | [m n 1 1] | No Batch  | Output will be a single convolve array |
| [m n 1 1] | [m n p 1] | [m n p 1] | Filter is Batched | p filters applied to same input |
| [m n p 1] | [m n 1 1] | [m n p 1] | Signal is Batched | 1 filter applied to p inputs |
| [m n p 1] | [m n p 1] | [m n p 1] | Identical Batches | p filters applied to p inputs in one-to-one correspondence |
| [m n p 1] | [m n 1 q] | [m n p q] | Non-overlapping batches | q filters applied to p inputs in to produce p x q results |
| [m n 1 p] | [m n q 1] | [m n q p] | Non-overlapping batches | q filters applied to p inputs in to produce q x p results |


\page signal_func_fft_desc fft

The Fast Fourier Transform (FFT) is an efficient algorithm to compute the discrete Fourier
transform (DFT) of a signal or array. This is most commonly used to convert data in the
time (or space) domain to the frequency domain, Then, the inverse FFT (iFFT) is used to
return the data to the original domain.

There are numerous algorithms to compute the FFT of an array, and the specifics of the
algorithm depend on the target hardware. Most algorithms, however, use a Cooley-Tukey
scheme in a divide-and-conquer approach.

\note There are some convenience functions provided for fft where normalization
factor is not required as input paramter. In such cases, the normalization
factor is calculated internally based on the input data provided.

*/

//=====================================================================
/**
\addtogroup arrayfire_func
@{

\defgroup signal_func_convolve convolve
\ingroup convolve_mat

\brief Convolution Integral for any dimensional data

\copydoc signal_func_conv_desc

\copydoc signal_func_conv2_batch_desc




\defgroup signal_func_convolve1 convolve1
\ingroup convolve_mat

\brief Convolution Integral for one dimensional data

\copydoc signal_func_conv_desc

For example, if the input size is m along 0th dimension, then the possible batch operations are as follows.

| Input Signal Dimensions | Filter Dimensions | Output Dimensions | Batch Mode | Explanation |
|:-----------------------:|:-----------------:|:-----------------:|:----------:|:------------|
| [m n 1 1] | [m n 1 1] | [m n 1 1] | No Batch  | Output will be a single convolve array |
| [m n 1 1] | [m n p 1] | [m n p 1] | Filter is Batched | p filters applied to same input |
| [m n p 1] | [m n 1 1] | [m n p 1] | Signal is Batched | 1 filter applied to p inputs |
| [m n p 1] | [m n p 1] | [m n p 1] | Identical Batches | p filters applied to p inputs in one-to-one correspondence |
| [m n p 1] | [m n 1 q] | [m n p q] | Non-overlapping batches | q filters applied to p inputs in to produce p x q results |
| [m n 1 p] | [m n q 1] | [m n q p] | Non-overlapping batches | q filters applied to p inputs in to produce q x p results |


\defgroup signal_func_convolve2 convolve2
\ingroup convolve_mat

\brief Convolution Integral for two dimensional data

\copydoc signal_func_conv_desc

\copydoc signal_func_conv2_batch_desc



\defgroup signal_func_convolve3 convolve3
\ingroup convolve_mat

\brief Convolution Integral for three dimensional data

\copydoc signal_func_conv_desc

For example, if the signal is three dimensional with m, n & p sizes along the 0th, 1st & 2nd dimensions
respectively, then the possible batch operations are as follows.

| Input Signal Dimensions | Filter Dimensions | Output Dimensions | Batch Mode | Explanation |
|:-----------------------:|:-----------------:|:-----------------:|:----------:|:------------|
| [m n 1 1] | [m n 1 1] | [m n 1 1] | No Batch  | Output will be a single convolve array |
| [m n 1 1] | [m n p 1] | [m n p 1] | Filter is Batched | p filters applied to same input |
| [m n p 1] | [m n 1 1] | [m n p 1] | Signal is Batched | 1 filter applied to p inputs |
| [m n p 1] | [m n p 1] | [m n p 1] | Identical Batches | p filters applied to p inputs in one-to-one correspondence |
| [m n p 1] | [m n 1 q] | [m n p q] | Non-overlapping batches | q filters applied to p inputs in to produce p x q results |
| [m n 1 p] | [m n q 1] | [m n q p] | Non-overlapping batches | q filters applied to p inputs in to produce q x p results |

===============================================================================

\defgroup signal_func_fft_convolve fftConvolve
\ingroup convolve_mat

\brief Convolution using Fast Fourier Transform

\copydoc signal_func_conv_desc

===============================================================================

\defgroup signal_func_fft_convolve2 fftConvolve2
\ingroup convolve_mat

\brief 2D Convolution using Fast Fourier Transform

\copydoc signal_func_conv_desc

===============================================================================

\defgroup signal_func_fft_convolve3 fftConvolve3
\ingroup convolve_mat

\brief 3D Convolution using Fast Fourier Transform

\copydoc signal_func_conv_desc

===============================================================================

\defgroup signal_func_fft fft
\ingroup fft_mat

\brief Fast Fourier Transform

\copydoc signal_func_fft_desc


\defgroup signal_func_fft2 fft2
\ingroup fft_mat

\brief Fast Fourier Transform

\copydoc signal_func_fft_desc


\defgroup signal_func_fft3 fft3
\ingroup fft_mat

\brief Fast Fourier Transform

\copydoc signal_func_fft_desc


\defgroup signal_func_ifft ifft
\ingroup fft_mat

\brief Fast Fourier Transform

\copydoc signal_func_fft_desc


\defgroup signal_func_ifft2 ifft2
\ingroup fft_mat

\brief Fast Fourier Transform

\copydoc signal_func_fft_desc


\defgroup signal_func_ifft3 ifft3
\ingroup fft_mat

\brief Fast Fourier Transform

\copydoc signal_func_fft_desc


\defgroup signal_func_fft_r2c fftR2C
\ingroup fft_mat

\brief Real to Complex Fast Fourier Transform


\defgroup signal_func_fft_c2r fftC2R
\ingroup fft_mat

\brief Complex to Real Fast Fourier Transform


\defgroup signal_func_approx1 approx1
\ingroup approx_mat

approx1 interpolates data along one dimension. Interpolation computes
for values of unknown points out of known ones.

The multi-dimensional (>=1D) input array, `in`, contains known values
to be used for interpolation. These known values lie on a 1D
interpolation grid - a one-dimensional, uniformly-spaced grid of
points. Interpolation is performed to obtain values for any unknown
points on the grid. The index values of the grid can be specified with
the `grid_beg` and `grid_step` arguments.

The position array (<=1D), `pos`, contains a combination of known and
unkown positions/indices on the interpolation grid. The position
array, `pos`, must be one-dimensional and must lead across the
dimension in which the measurements will be made in the input array.

Any unknown position/index values that lie within the interpolation
grid range will be calculated for using interpolation. Unknown points
that are outside of the interpolation grid range will be replaced with
the `off_grid` value. Known points will be replaced with corresponding
values from the input array.

The interpolation dimension, `interp_dim`, is the leading dimension
used to measure across the interpolation grid. Interpolation is thus
performed along the same dimension of the input array.

The uniformly-spaced one-dimensional interpolation grid on which the
input values lie on can be adjusted with the corresponding `grid_beg`
and `grid_step` arguments. A standard uniform interpolation grid with
equally spaced indices in the range of [0,n) can be achieved with grid
begin and step values of 0 and 1, respectively. A standard uniform
grid will be used in the case that the interpolating dimension as well
as the grid start and step values are not passed in.

The type of interpolation to be performed is controlled with the
`method` argument. The following are the different interpolation types
supported by `approx1()`:

- Nearest neighbor interpolation - \ref AF_INTERP_NEAREST
- Linear interpolation (default) - \ref AF_INTERP_LINEAR, \ref AF_INTERP_LINEAR_COSINE
- Cubic interpolation - \ref AF_INTERP_CUBIC, \ref AF_INTERP_CUBIC_SPLINE
- Lower interpolation - \ref AF_INTERP_LOWER

Unless specified, linear interpolation is performed by default. Refer
to \ref af_interp_type for more information about ArrayFire's
interpolation types.

Interpolation positions outside of the interpolation grid range are
not extrapolated. Instead, those values default to `off_grid`, whose
default value is 0.

\snippet test/approx1.cpp ex_signal_approx1

\defgroup signal_func_approx2 approx2
\ingroup approx_mat

approx2 interpolates data along two dimensions. Interpolation computes
for values of unknown points out of known ones.

The multi-dimensional (>=2D) input array, `in`, contains known values
to be used for interpolation. These known values lie on a 2D
interpolation grid - a two-dimensional, uniformly-spaced grid of
points. Interpolation is performed to obtain values for any unknown
points on the grid. The index values of the grid can be specified with
the `grid_beg` and `grid_step` arguments.

Two position arrays (<=2D), `pos0` and `pos1`, contain a combination
of known and unkown positions/indices on the interpolation grid. Each
of the position arrays must be of at most two dimensions. The index
values for each of the position arrays is read along the dimensions
specified by `pos0_interp_dim` and `pos1_interp_dim`, respectively.

Any unknown position/index values that lie within the interpolation
grid range will be calculated for using interpolation. Unknown points
that are outside of the interpolation grid range will be replaced with
the `off_grid` value. Known points will be replaced with corresponding
values from the input array.

The two interpolation dimensions, `pos0_interp_dim` and
`pos1_interp_dim`, correspond to the dimensions that the `pos0` and
`pos1` arrays will be measured across the interpolation
grid. Interpolation is thus performed along both specified dimensions
of the input array.

The uniformly-spaced two-dimensional interpolation grid on which the
input values lie on can be adjusted with the corresponding grid begin
and step arguments. A standard uniform interpolation grid with equally
spaced indices in the range of [0,n) can be achieved with grid begin
and step values of 0 and 1, respectively. A standard uniform grid will
be used in the case that the interpolating dimension as well as the
grid start and step values are not passed in.

All of the interpolation types defined in \ref af_interp_type are
supported by approx2(). ArrayFire performs linear interpolation by
default.

Unless specified, linear interpolation is performed by default. Refer
to \ref af_interp_type for more information about ArrayFire's
interpolation types.

Interpolation positions outside of the interpolation grid range are
not extrapolated. Instead, those values default to `off_grid`, whose
default value is 0.

\snippet test/approx2.cpp ex_signal_approx2

\defgroup signal_func_fir fir
\ingroup sigfilt_mat

\brief This function implements a Finite Impulse Filter

Finite impulse filters take an input **x** and a co-efficient array **b** to generate an output **y** such that:

       \f$y[n] = \sum_{i = 0}^N b_i . x[n]\f$


\defgroup signal_func_iir iir
\ingroup sigfilt_mat

\brief This function implements a Infinite Impulse Filter

Iinite impulse filters take an input **x** and a feedforward array **b**, feedback array **a** to generate an output **y** such that:

       \f$\sum_{j = 0}^Q a_j . y[n] = \sum_{i = 0}^P b_i . x[n]\f$
@}
*/
