
/*!

\page signal_func_conv_desc Convolution

A convolution is a common operation between a source array, a, and a filter (or kernel) array b.
The answer to the convolution is the same as computing the coefficients in polynomial multiplication,
if a and b are the coefficients.

Another way to think about it is that the filter kernel is centered on each pixel in a,
and the output for that pixel or data point is the sum of the products.

Depending on the dimensions of the input signal and the filter signal, any one of the following
batch mode convolutions take place.

- **No Batch**   - Single filter applied to single input.
- **Filter is Batched**  - Many filters applied on same input
- **Signal is Batched**  - Single filter applied to a set of inputs.
- **Identical Batches** - A set of filters applied onto to a set of inputs in one-to-one correspondence.
- **Non overlapping Batches** - All batched filters are applied to all batched signals. The batch dimension of Signal and Filter **should not** be the same.



\page signal_func_conv2_batch_desc convolve2

For example, if the signal is two dimensional with m & n as sizes along the 0th & 1st dimensions
respectively, then the possible batch operations are as follows.

| Input Signal Dimensions | Filter Dimensions | Output Dimensions | Batch Mode | Explanation |
|:-----------------------:|:-----------------:|:-----------------:|:----------:|:------------|
| [m n 1 1] | [m n 1 1] | [m n 1 1] | No Batch  | Output will be a single convolve array |
| [m n 1 1] | [m n p 1] | [m n p 1] | Filter is Batched | p filters applied to same input |
| [m n p 1] | [m n 1 1] | [m n p 1] | Signal is Batched | 1 filter applied to p inputs |
| [m n p 1] | [m n p 1] | [m n p 1] | Identical Batches | p filters applied to p inputs in one-to-one correspondence |
| [m n p 1] | [m n 1 q] | [m n p q] | Non-overlapping batches | q filters applied to p inputs in to produce p x q results |
| [m n 1 p] | [m n q 1] | [m n q p] | Non-overlapping batches | q filters applied to p inputs in to produce q x p results |


\page signal_func_fft_desc fft

The Fast Fourier Transform (FFT) is an efficient algorithm to compute the discrete Fourier
transform (DFT) of a signal or array. This is most commonly used to convert data in the
time (or space) domain to the frequency domain, Then, the inverse FFT (iFFT) is used to
return the data to the original domain.

There are numerous algorithms to compute the FFT of an array, and the specifics of the
algorithm depend on the target hardware. Most algorithms, however, use a Cooley-Tukey
scheme in a divide-and-conquer approach.

\note There are some convenience functions provided for fft where normalization
factor is not required as input paramter. In such cases, the normalization
factor is calculated internally based on the input data provided.

*/

//=====================================================================
/**
\addtogroup arrayfire_func
@{

\defgroup signal_func_convolve convolve
\ingroup convolve_mat

\brief Convolution Integral for any dimensional data

\copydoc signal_func_conv_desc

\copydoc signal_func_conv2_batch_desc




\defgroup signal_func_convolve1 convolve1
\ingroup convolve_mat

\brief Convolution Integral for one dimensional data

\copydoc signal_func_conv_desc

For example, if the input size is m along 0th dimension, then the possible batch operations are as follows.

| Input Signal Dimensions | Filter Dimensions | Output Dimensions | Batch Mode | Explanation |
|:-----------------------:|:-----------------:|:-----------------:|:----------:|:------------|
| [m n 1 1] | [m n 1 1] | [m n 1 1] | No Batch  | Output will be a single convolve array |
| [m n 1 1] | [m n p 1] | [m n p 1] | Filter is Batched | p filters applied to same input |
| [m n p 1] | [m n 1 1] | [m n p 1] | Signal is Batched | 1 filter applied to p inputs |
| [m n p 1] | [m n p 1] | [m n p 1] | Identical Batches | p filters applied to p inputs in one-to-one correspondence |
| [m n p 1] | [m n 1 q] | [m n p q] | Non-overlapping batches | q filters applied to p inputs in to produce p x q results |
| [m n 1 p] | [m n q 1] | [m n q p] | Non-overlapping batches | q filters applied to p inputs in to produce q x p results |


\defgroup signal_func_convolve2 convolve2
\ingroup convolve_mat

\brief Convolution Integral for two dimensional data

\copydoc signal_func_conv_desc

\copydoc signal_func_conv2_batch_desc



\defgroup signal_func_convolve3 convolve3
\ingroup convolve_mat

\brief Convolution Integral for three dimensional data

\copydoc signal_func_conv_desc

For example, if the signal is three dimensional with m, n & p sizes along the 0th, 1st & 2nd dimensions
respectively, then the possible batch operations are as follows.

| Input Signal Dimensions | Filter Dimensions | Output Dimensions | Batch Mode | Explanation |
|:-----------------------:|:-----------------:|:-----------------:|:----------:|:------------|
| [m n 1 1] | [m n 1 1] | [m n 1 1] | No Batch  | Output will be a single convolve array |
| [m n 1 1] | [m n p 1] | [m n p 1] | Filter is Batched | p filters applied to same input |
| [m n p 1] | [m n 1 1] | [m n p 1] | Signal is Batched | 1 filter applied to p inputs |
| [m n p 1] | [m n p 1] | [m n p 1] | Identical Batches | p filters applied to p inputs in one-to-one correspondence |
| [m n p 1] | [m n 1 q] | [m n p q] | Non-overlapping batches | q filters applied to p inputs in to produce p x q results |
| [m n 1 p] | [m n q 1] | [m n q p] | Non-overlapping batches | q filters applied to p inputs in to produce q x p results |

===============================================================================

\defgroup signal_func_fft_convolve fftConvolve
\ingroup convolve_mat

\brief Convolution using Fast Fourier Transform

\copydoc signal_func_conv_desc

===============================================================================

\defgroup signal_func_fft_convolve2 fftConvolve2
\ingroup convolve_mat

\brief 2D Convolution using Fast Fourier Transform

\copydoc signal_func_conv_desc

===============================================================================

\defgroup signal_func_fft_convolve3 fftConvolve3
\ingroup convolve_mat

\brief 3D Convolution using Fast Fourier Transform

\copydoc signal_func_conv_desc

===============================================================================

\defgroup signal_func_fft fft
\ingroup fft_mat

\brief Fast Fourier Transform

\copydoc signal_func_fft_desc


\defgroup signal_func_fft2 fft2
\ingroup fft_mat

\brief Fast Fourier Transform

\copydoc signal_func_fft_desc


\defgroup signal_func_fft3 fft3
\ingroup fft_mat

\brief Fast Fourier Transform

\copydoc signal_func_fft_desc


\defgroup signal_func_ifft ifft
\ingroup fft_mat

\brief Fast Fourier Transform

\copydoc signal_func_fft_desc


\defgroup signal_func_ifft2 ifft2
\ingroup fft_mat

\brief Fast Fourier Transform

\copydoc signal_func_fft_desc


\defgroup signal_func_ifft3 ifft3
\ingroup fft_mat

\brief Fast Fourier Transform

\copydoc signal_func_fft_desc


\defgroup signal_func_fft_r2c fftR2C
\ingroup fft_mat

\brief Real to Complex Fast Fourier Transform


\defgroup signal_func_fft_c2r fftC2R
\ingroup fft_mat

\brief Complex to Real Fast Fourier Transform


\defgroup signal_func_approx1 approx1
\ingroup approx_mat

Performs interpolation on data along a single dimension.

Interpolation is the process of computing for unknown values within a
continuous range described by a discrete set of known values.

`in`, the N-D input array, is comprised of known values that will be
used for interpolation in order to compute for values at unknown
indices. These known values correspond to a uniformly-spaced range of
indices determined by `idx_start`, `idx_step`.

`idx_start` (default: 0.0) defines the first index in the range.

`idx_step` (default: 1.0) defines the uniform spacing value used
between subsequent indices.

`interp_dim` (default: 0) defines the dimension which we'd like to
perform interpolation across respective to the input array.

`pos`, the positions array, contains indices whose values we want to
find along corresponding dimension `interp_dim` in the input
array. Values of **known indices** will be looked up in the input
array, while values of **unknown indices** will be found via
interpolation. Indices outside of the index range are not
extrapolated. Instead, those values are set to `off_grid`, whose
default value is 0.0.

Using the default start and step values,

\image html approx1_default_idx.png "approx1() using idx_start=0.0, idx_step=1.0"

If instead, we chose 10 for start and step,

\image html approx1_arbitrary_idx.png "approx1() using idx_start=10.0, idx_step=10.0"

`method` controls the interpolation method to be performed. Several
interpolation methods are supported by `approx1()`:

- Nearest neighbor interpolation - \ref AF_INTERP_NEAREST
- Linear interpolation (default) - \ref AF_INTERP_LINEAR, \ref AF_INTERP_LINEAR_COSINE
- Cubic interpolation - \ref AF_INTERP_CUBIC, \ref AF_INTERP_CUBIC_SPLINE
- Lower interpolation - \ref AF_INTERP_LOWER

Unless specified, linear interpolation is performed by default. Refer
to \ref af_interp_type for more information about ArrayFire's
interpolation types.

It is not necessary to specify the `idx_start`, `idx_step`, and
`interp_dim` as long as desired values match the default ones.

\snippet test/approx1.cpp ex_signal_approx1

\defgroup signal_func_approx2 approx2
\ingroup approx_mat

Performs interpolation on data along two dimensions.

Interpolation is the process of computing for unknown values within a
continuous range described by a discrete set of known values. For 2D
interpolation, two sets of values, indices, and interpolation
dimensions are necessary.

`in`, the N-D input array, is comprised of known values that will be
used for interpolation in order to compute for values at unknown
indices. These known values correspond to a uniformly-spaced range of
indices determined by:

- `idx_start_dim0` and `idx_step_dim0` along `interp_dim0`
- `idx_start_dim1` and `idx_step_dim1` along `interp_dim1`

`idx_start_dim0` (default: 0.0) and `idx_start_dim1` (default: 0.0) each
define the first index value along their respective dimension.

`idx_step_dim0` (default: 1.0) and `idx_step_dim1` (default: 1.0) each
define the uniform spacing value used between subsequent indices along
their respective dimension.

`interp_dim0` (default: 0) and `interp_dim1` (default: 1), define the
dimensions which we'd like to perform interpolation across respective
to the input array.

`pos0` and `pos1`, the positions arrays, contain indices whose values
we want to find along corresponding dimensions `interp_dim0` and
`interp_dim1` in the input array. Values of **known indices** will be
looked up in the input array, while values of **unknown indices** will
be found via interpolation. Indices outside of the index range are not
extrapolated. Instead, those values are set to `off_grid`, whose
default value is 0.0.

`method` controls the interpolation method to be performed. All of the
interpolation methods defined in \ref af_interp_type are supported by
approx2(). Unless specified, linear interpolation is performed by
default.

It is not necessary to specify the start arguments (`idx_start_dim0`,
`idx_start_dim1`), step arguments (`idx_step_dim0` and
`idx_step_dim1`), and dimension arguments (`interp_dim0` and
`interp_dim1`) as long as desired values match the default ones.

\snippet test/approx2.cpp ex_signal_approx2

\defgroup signal_func_fir fir
\ingroup sigfilt_mat

\brief This function implements a Finite Impulse Filter

Finite impulse filters take an input **x** and a co-efficient array **b** to generate an output **y** such that:

       \f$y[n] = \sum_{i = 0}^N b_i . x[n]\f$


\defgroup signal_func_iir iir
\ingroup sigfilt_mat

\brief This function implements a Infinite Impulse Filter

Iinite impulse filters take an input **x** and a feedforward array **b**, feedback array **a** to generate an output **y** such that:

       \f$\sum_{j = 0}^Q a_j . y[n] = \sum_{i = 0}^P b_i . x[n]\f$
@}
*/
