/*******************************************************
 * Copyright (c) 2019, ArrayFire
 * All rights reserved.
 *
 * This file is distributed under 3-clause BSD license.
 * The complete license agreement can be obtained at:
 * http://arrayfire.com/licenses/BSD-3-Clause
 ********************************************************/

/// This file contains platform independent utility functions
#include <cstdlib>
#include <string>
#include <cstring>

#if defined(OS_WIN)
#include <Windows.h>
#endif

#include <af/defines.h>
#include <common/util.hpp>
#include <common/defines.hpp>

using std::string;

string getEnvVar(const std::string &key) {
#if defined(OS_WIN)
    DWORD bufSize =
        32767;  // limit according to GetEnvironment Variable documentation
    string retVal;
    retVal.resize(bufSize);
    bufSize = GetEnvironmentVariable(key.c_str(), &retVal[0], bufSize);
    if (!bufSize) {
        return string("");
    } else {
        retVal.resize(bufSize);
        return retVal;
    }
#else
    char *str = getenv(key.c_str());
    return str == NULL ? string("") : string(str);
#endif
}

const char *getName(af_dtype type) {
    switch (type) {
        case f32: return "float";
        case f64: return "double";
        case c32: return "complex float";
        case c64: return "complex double";
        case u32: return "unsigned int";
        case s32: return "int";
        case u16: return "unsigned short";
        case s16: return "short";
        case u64: return "unsigned long long";
        case s64: return "long long";
        case u8: return "unsigned char";
        case b8: return "bool";
        default: return "unknown type";
    }
}

void saveKernel(const std::string& funcName, const std::string& jit_ker, const std::string& ext) {
  static const char* jitKernelsOutput = getenv(saveJitKernelsEnvVarName);
  if (!jitKernelsOutput)
    return;
  if (std::strcmp(jitKernelsOutput, "stdout") == 0) {
    fprintf(stdout, jit_ker.c_str());
    return;
  }
  if (std::strcmp(jitKernelsOutput, "stderr") == 0) {
    fprintf(stderr, jit_ker.c_str());
    return;
  }
  // Path to a folder  
  const std::string ffp = std::string(jitKernelsOutput) + AF_PATH_SEPARATOR + funcName + ext;
  FILE* f = fopen(ffp.c_str(), "w");
  if (!f) {
    fprintf(stderr, "Cannot open file %s\n", ffp.c_str());
    return;
  }
  if (fputs(jit_ker.c_str(), f) == EOF)
    fprintf(stderr, "Failed to write kernel to file %s\n", ffp.c_str());
  fclose(f);
}
