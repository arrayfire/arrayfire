/*******************************************************
 * Copyright (c) 2014, ArrayFire
 * All rights reserved.
 *
 * This file is distributed under 3-clause BSD license.
 * The complete license agreement can be obtained at:
 * http://arrayfire.com/licenses/BSD-3-Clause
 ********************************************************/

/***********************************************************************
 * Based on MAGMA library http://icl.cs.utk.edu/magma/
 * Below is the original copyright.
 *
 *   -- MAGMA (version 1.1) --
 *      Univ. of Tennessee, Knoxville
 *      Univ. of California, Berkeley
 *      Univ. of Colorado, Denver
 *      @date
 *
 *      @precisions normal z -> s d c
 *
 *      @author Mark Gates
 *
 *      auto-converted from zlaset.cu
 *
 * -- Innovative Computing Laboratory
 * -- Electrical Engineering and Computer Science Department
 * -- University of Tennessee
 * -- (C) Copyright 2009-2013
 *
 * Redistribution  and  use  in  source and binary forms, with or without
 * modification,  are  permitted  provided  that the following conditions
 * are met:
 *
 * * Redistributions  of  source  code  must  retain  the above copyright
 *   notice,  this  list  of  conditions  and  the  following  disclaimer.
 * * Redistributions  in  binary  form must reproduce the above copyright
 *   notice,  this list of conditions and the following disclaimer in the
 *   documentation  and/or other materials provided with the distribution.
 * * Neither  the  name of the University of Tennessee, Knoxville nor the
 *   names of its contributors may be used to endorse or promote products
 *   derived from this software without specific prior written permission.
 *
 * THIS  SOFTWARE  IS  PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS''  AND  ANY  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A  PARTICULAR  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT NOT
 * LIMITED  TO,  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA,  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY  OF  LIABILITY,  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF  THIS  SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 **********************************************************************/

/*
    Divides matrix into ceil( m/BLK_X ) x ceil( n/BLK_Y ) blocks.
    Each block has BLK_X threads.
    Each thread loops across one row, updating BLK_Y entries.

    Code similar to zlacpy, zlag2c, clag2z, zgeadd.
*/

#if IS_CPLX
#define IS_EQUAL(lhs, rhs) ((rhs.x == lhs.x) && (rhs.y == lhs.y))
#else
#define IS_EQUAL(lhs, rhs) ((rhs == lhs))
#endif

kernel void laset_full(int m, int n, T offdiag, T diag, global T *A,
                         unsigned long A_offset, int lda) {
    A += A_offset;

    int ind = get_group_id(0) * BLK_X + get_local_id(0);
    int iby = get_group_id(1) * BLK_Y;
    /* check if full block-column && (below diag || above diag || offdiag ==
     * diag) */
    bool full =
        (iby + BLK_Y <= n &&
         (ind >= iby + BLK_Y || ind + BLK_X <= iby || IS_EQUAL(offdiag, diag)));
    /* do only rows inside matrix */
    if (ind < m) {
        A += ind + iby * lda;
        if (full) {
// full block-column, off-diagonal block or offdiag == diag
#pragma unroll
            for (int j = 0; j < BLK_Y; ++j) { A[j * lda] = offdiag; }
        } else {
            // either partial block-column or diagonal block
            for (int j = 0; j < BLK_Y && iby + j < n; ++j) {
                if (iby + j == ind)
                    A[j * lda] = diag;
                else
                    A[j * lda] = offdiag;
            }
        }
    }
}

/*
    Similar to zlaset_full, but updates only the diagonal and below.
    Blocks that are fully above the diagonal exit immediately.

    Code similar to zlacpy, zlat2c, clat2z.
*/
kernel void laset_lower(int m, int n, T offdiag, T diag, global T *A,
                          unsigned long A_offset, int lda) {
    A += A_offset;

    int ind = get_group_id(0) * BLK_X + get_local_id(0);
    int iby = get_group_id(1) * BLK_Y;
    /* check if full block-column && (below diag) */
    bool full = (iby + BLK_Y <= n && (ind >= iby + BLK_Y));
    /* do only rows inside matrix, and blocks not above diag */
    if (ind < m && ind + BLK_X > iby) {
        A += ind + iby * lda;
        if (full) {
// full block-column, off-diagonal block
#pragma unroll
            for (int j = 0; j < BLK_Y; ++j) { A[j * lda] = offdiag; }
        } else {
            // either partial block-column or diagonal block
            for (int j = 0; j < BLK_Y && iby + j < n; ++j) {
                if (iby + j == ind)
                    A[j * lda] = diag;
                else if (ind > iby + j)
                    A[j * lda] = offdiag;
            }
        }
    }
}

/*
    Similar to zlaset_full, but updates only the diagonal and above.
    Blocks that are fully below the diagonal exit immediately.

    Code similar to zlacpy, zlat2c, clat2z.
*/
kernel void laset_upper(int m, int n, T offdiag, T diag, global T *A,
                          unsigned long A_offset, int lda) {
    A += A_offset;

    int ind = get_group_id(0) * BLK_X + get_local_id(0);
    int iby = get_group_id(1) * BLK_Y;
    /* check if full block-column && (above diag) */
    bool full = (iby + BLK_Y <= n && (ind + BLK_X <= iby));
    /* do only rows inside matrix, and blocks not below diag */
    if (ind < m && ind < iby + BLK_Y) {
        A += ind + iby * lda;
        if (full) {
// full block-column, off-diagonal block
#pragma unroll
            for (int j = 0; j < BLK_Y; ++j) { A[j * lda] = offdiag; }
        } else {
            // either partial block-column or diagonal block
            for (int j = 0; j < BLK_Y && iby + j < n; ++j) {
                if (iby + j == ind)
                    A[j * lda] = diag;
                else if (ind < iby + j)
                    A[j * lda] = offdiag;
            }
        }
    }
}
